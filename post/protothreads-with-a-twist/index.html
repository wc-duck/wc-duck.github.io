<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<title>&#34;ProtoThreads&#34; with a twist.</title>
<meta name="description" 
      content=""
>

  




<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link
  rel="alternate"
  type="application/rss+xml"
  href="https://kihlander.net/index.xml"
  title="What could possibly go wrong?"
/>
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="&#34;ProtoThreads&#34; with a twist."/>
<meta name="twitter:description" content="For a long time I&rsquo;v been interested in running game-specific/entity-specific code in coroutines. Something like the following.
void some_game_object_behavior( entity ent, ... ) { pnt3 points[] = { {1,1,1}, {2,2,2}, {3,3,3}, {4,4,4} }; int pos = 0; while(entity_alive(ent)) { // move the entity to a position and yield coroutine while movement is ongoing. move_to(ent, points[pos % ARRAY_LENGTH(points)]); pos&#43;&#43;; for(int i = 0; i &lt; 4; &#43;&#43;i) { shoot_bullet(ent); wait_sec(ent, 2); // do nothing for 2 seconds and yield the coroutine for that duration."/>



<link rel="stylesheet" href="https://kihlander.net/fontawesome/css/all.min.css" />




<link
  crossorigin="anonymous"
  href="/css/styles.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>




<link
  id="dark-mode-theme"
  crossorigin="anonymous"
  href="/css/dark.min.css"
  integrity=""
  rel="preload stylesheet"
  as="style"
/>


<script>
  var darkTheme = document.getElementById('dark-mode-theme')
  var storedTheme = localStorage.getItem('dark-mode-storage')

  if (storedTheme === 'dark') {
    darkTheme.disabled = false
  } else if (storedTheme === 'light') {
    darkTheme.disabled = true
  }
</script>


<script defer crossorigin="anonymous" src="/js/theme.js" integrity=""></script>


<script defer crossorigin="anonymous" src="/js/instantpage.min.js" integrity=""></script><meta name="generator" content="Hugo 0.121.2">
  </head>
  <body>
    
  




  <header>
    <nav class="navbar">
  <div class="nav">
    
      <a href="https://kihlander.net/" class="nav-logo">
        <img
          src="https://kihlander.net/images/logo.png"
          width="50"
          height="50"
          alt="Logo"
        />
      </a>
    

    <ul class="nav-links">
      
        
          <li>
            <a href="/about/" id="About"
              ><em class="fas fa-user fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/tags" id="Tags"
              ><em class="fas fa-tag fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/search" id="Search"
              ><em class="fas fa-search fa-lg"></em
            ></a>
          </li>
          
      
        
          <li>
            <a href="/archives" id="Archives"
              ><em class="fas fa-archive fa-lg"></em
            ></a>
          </li>
          
      
    </ul>
  </div>
</nav>

    <div class="intro-header">
      <div class="container">
        <div class="post-heading">
          
            <h1>
              &#34;ProtoThreads&#34; with a twist.
            </h1>
          
          
            <span class="meta-post">
  <em class="fa fa-calendar-alt"></em
  >&nbsp;Nov 20, 2018
  
</span>

          
        </div>
      </div>
    </div>
  </header>
  

    
  <div class="container" role="main">
    <article class="article" class="blog-post">
      
  <p>For a long time I&rsquo;v been interested in running game-specific/entity-specific code in coroutines.
Something like the following.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">some_game_object_behavior</span>( entity ent, ... )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    pnt3 points[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        {<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">2</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>},
</span></span><span style="display:flex;"><span>        {<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">4</span>}
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(entity_alive(ent))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// move the entity to a position and yield coroutine while movement is ongoing.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        move_to(ent, points[pos <span style="color:#f92672">%</span> ARRAY_LENGTH(points)]);
</span></span><span style="display:flex;"><span>        pos<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            shoot_bullet(ent);
</span></span><span style="display:flex;"><span>            wait_sec(ent, <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// do nothing for 2 seconds and yield the coroutine for that duration.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above example is slightly simplified but I hope that it get the point across, that I want to be able
to suspend code-execution at specific points and wait for certain actions to complete. Writing  one-off
game-code in this fashion might be a good way to work, especially when adding wait_for_any() and  wait_for_all()
etc.</p>
<p>So when I finally decided to take a stab at trying that out I started out by looking at how to implement the
actual coroutines. There are a couple of libraries out there that I looked at for coroutines in c/c++ such as:</p>
<ul>
<li><a href="https://github.com/hnes/libaco">libaco</a></li>
<li><a href="http://libdill.org/">libdill</a></li>
<li><a href="http://libmill.org/">libmill</a></li>
</ul>
<p>Both libdill and libmill feel too &lsquo;opinionated&rsquo; on how they want you to structure your code ( not that
weird since the both sets out to re-implement go:s goroutines in c ) and also feels &lsquo;heavier&rsquo; than what I
need.
libaco however sparked my interest, it looked quite lean and not too opinionated, i.e. it looks really nice!
But there is a big BUT, no windows support yet =/ I do most of my development on Linux but throwing Windows
support out of the &ldquo;window&rdquo; (<strong>badumtish</strong>) is not something I want to do.
According to the issue-tracker it is in &ldquo;the pipe&rdquo; but it is not supported as of writing this.</p>
<p>This lead me to fire of a question on twitter about alternatives and where <a href="https://twitter.com/randypgaul">@RandyPGaul</a>
pointed out something that I had looked at before but totally forgot about, coroutines/protothreads based
on &ldquo;duff&rsquo;s device&rdquo;.</p>
<p>Since this technique is already well documented on the interwebs I&rsquo;ll just link to the original
article here and wait until you have read it ( if you haven&rsquo;t already ).</p>
<p><a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">coroutines in c</a></p>
<p>Read it yet? Good!</p>
<p>Here are a few other links to libs that implement these kind of coroutines.</p>
<ul>
<li><a href="http://dunkels.com/adam/pt/">protothreads</a></li>
<li><a href="https://github.com/zserge/pt">zserge/pt</a></li>
<li><a href="https://github.com/RandyGaul/cute_headers/blob/master/cute_coroutine.h">cute_coroutine</a></li>
</ul>
<p>What I like about this solution is that it is &ldquo;just code&rdquo; so it should in theory work on any platform without
platform-specific code. It should also work with emscripten ( that I shall get running any day now!!! ;) ).</p>
<p>There are however things that I am missing from these otherwise fine libraries.
A major one is based in how I plan to use them. I plan to have all my &ldquo;behaviors&rdquo; run one coroutine and
have some kind of simple &ldquo;scheduler&rdquo; run them. Something simple as having all &ldquo;active&rdquo; coroutines in a list,
remove them from the list when waiting for something, and update them in a loop. However doing that with the
above libs would require me keeping track of what functions are associated with each coroutine state.</p>
<p>Also local variables/state is not handled by the above libs and would need to be handled by passing in some
kind of state-struct, that would need to be different for each &ldquo;behavior&rdquo; and also be tracked by the above
mentioned system.</p>
<p>2 of the 3 libs also fails to handle calling another coroutine-function from within a coroutine and by that
having the sub-call control the state of the top-level coroutine. For example if a sub-call does a yield or
wait the entire call-hierarchy should do the same (cute_coroutine.h solves this for a fixed depth of sub-calls).</p>
<p>So what do you do when you have an interesting itch to scratch? You scratch it of course :)</p>
<h1 id="solving-the-issues">Solving the issues!</h1>
<p>As any decent NIH-addict I decided to try myself and see what I could do and came to the conclusion that all
the above issues can be solved by adding a small stack to each coroutine, i.e. almost do what the compiler
does!</p>
<p>Introducing my boringly named coroutine lib/header, <a href="https://github.com/wc-duck/coro">coro</a>.</p>
<p>As mentioned above the only real difference between <code>coro</code> and the above mentioned libs are that each coroutine
in coro MAY have a stack associated with it where the system itself can push data and reset when a coroutine completes.</p>
<blockquote>
<p>Warning for you C-all-the-way people, there be some usage of C++ in this piece of code! But I guess it wouldn&rsquo;t
be that hard to C:ify the lib if there is demand for it!</p>
</blockquote>
<p>The library does nothing particularly fancy at its core, the simplest coroutine would be implemented and updated
like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">my_coro</span>( coro<span style="color:#f92672">*</span> co, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// all coroutines need a matching co_begin/co_end-pair
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    co_begin(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... do stuff ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... yield execution of coroutine, i.e. introduce a yield-point in the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//     function where to continue execution on the next update ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">co_yield</span>(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    co_end(co);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run_it</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... create and initialize our coroutine ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    coro co;
</span></span><span style="display:flex;"><span>    co_init(<span style="color:#f92672">&amp;</span>co, <span style="color:#66d9ef">nullptr</span>, <span style="color:#ae81ff">0</span>, my_coro);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... resume until completed ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>co_completed(<span style="color:#f92672">&amp;</span>co))
</span></span><span style="display:flex;"><span>        co_resume(<span style="color:#f92672">&amp;</span>co);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But now to the meat of this post, how will adding a stack solve the above mentioned issues?</p>
<h2 id="general-coroutine-update">General coroutine update</h2>
<p>Well, this isn&rsquo;t solved by the stack, this is just solved by introducing a struct for the coroutines and storing a
function-ptr in it :) Now we have that out of the way, carry on.</p>
<h2 id="local-variables">Local variables</h2>
<p>Lets get to the stack-part and start with local variables. When we have a memory-area to store data in
the problem isn&rsquo;t really to store the data, it is how to make it nice to use.</p>
<p>As all the above mentioned libs, the same goes for coro, you can&rsquo;t just make a local variable and expect it to work</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">some_game_object_behavior</span>( coro<span style="color:#f92672">*</span> co, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> my_counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    co_begin(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;whoo %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">++</span>my_counter);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">co_yield</span>(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;whoo %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">++</span>my_counter);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">co_yield</span>(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;whoo %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">++</span>my_counter);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">co_yield</span>(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    co_end(co);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>One might expect for this to print:</p>
<blockquote>
<p>whoo 1</p>
<p>whoo 2</p>
<p>whoo 3</p>
</blockquote>
<p>But it will print</p>
<blockquote>
<p>whoo 1</p>
<p>whoo 1</p>
<p>whoo 1</p>
</blockquote>
<p>Why? If you read the article <a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">coroutines in c</a> ( you
did read it right? ) then you see the problem. The coroutines build on calling the function over and over until it
exits at the end. On each call it will initialize a local variable to 0, jump to the last position in the
function, increment and print.</p>
<p>Thats not good now, is it? &ldquo;Didn&rsquo;t you mention solving this with the stack&rdquo; you might think and that is correct.
<code>coro</code> has a pair of functions (actually a macros) called <code>co_locals_begin()</code>/<code>co_locals_end()</code> that is used like this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">some_game_object_behavior</span>( coro<span style="color:#f92672">*</span> co, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    co_locals_begin(co);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> my_counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// could be any amount of variables here!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    co_locals_end(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    co_begin(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;whoo %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">++</span>locals.my_counter);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">co_yield</span>(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;whoo %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">++</span>locals.my_counter);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">co_yield</span>(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;whoo %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">++</span>locals.my_counter);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">co_yield</span>(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    co_end(co);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>These macros will declare a local struct and instantiate a reference to one of these called <code>locals</code>, and guess where
that reference is pointing, into the stack! This variable will only be allocated from the stack when entering the
function for the first time, in the following calls it will just be fetched from the stack.</p>
<p>What this means is that we will have a struct that will be the same between all calls to our coroutine, that is not
exposed to the calling code and take the burden of keeping track of this away from the caller.</p>
<p>It might be interesting to have a look at how the macro work as well, if we just expand it and look at what is
generated.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">some_game_object_behavior</span>( coro<span style="color:#f92672">*</span> co, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_co_locals</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> my_counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(co<span style="color:#f92672">-&gt;</span>call_locals <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        co<span style="color:#f92672">-&gt;</span>call_locals <span style="color:#f92672">=</span> _co_stack_alloc( co,
</span></span><span style="display:flex;"><span>                                           <span style="color:#66d9ef">sizeof</span>(_co_locals),
</span></span><span style="display:flex;"><span>                                           <span style="color:#66d9ef">alignof</span>(_co_locals));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> (co<span style="color:#f92672">-&gt;</span>call_locals) _co_locals;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    _co_locals<span style="color:#f92672">&amp;</span> CORO_LOCALS_NAME <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((_co_locals<span style="color:#f92672">*</span>)co<span style="color:#f92672">-&gt;</span>call_locals);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    co_begin(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... function ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    co_end(co);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see it just declare a local struct and put everything between <code>co_locals_begin()</code>/<code>co_locals_end()</code> into it. Then,
if it is the first call, allocate data from the stack at the correct size/alignment. By placing the values in a struct we
can put all of this in one declare call + we get size/alignment of the entire block for free from the compiler.</p>
<p>Also, since c++ now supports &lsquo;inline&rsquo; initialization ( I guess there is a fancier name for it ) of member-variables we can
just write out or variables, set initial values and use <code>placement new</code> to initialize the values.</p>
<blockquote>
<p>Note to the C++:ers out there, currently no destructor is run on the locals but I guess that could be implemented in co_end()
if needed.</p>
</blockquote>
<h2 id="sub-calls">sub-calls</h2>
<p>With local variables out of the way, how about calling another coroutine function from the first one? Well, just to state the
obvious calling an ordinary function is just doing the call if someone was wondering. However say that you want to call a
function that can, by itself, yield execution?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">some_game_object_sub_behaviors1</span>( coro<span style="color:#f92672">*</span> co, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... do stuff ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    wait_for_timer(); <span style="color:#75715e">// how this is implemented is up to the user ;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... do other stuff ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">some_game_object_sub_behaviors2</span>( coro<span style="color:#f92672">*</span> co, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... do other cool stuff ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    wait_for_timer(); <span style="color:#75715e">// how this is implemented is up to the user ;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... DAMN THIS IS SOME COOL STUFF GOING ON HERE ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">some_game_object_behavior</span>( coro<span style="color:#f92672">*</span> co, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    co_begin(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... function ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// some_game_object_sub_behaviors1()?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// some_game_object_sub_behaviors2()?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    co_end(co);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Lucky for us we have the stack and <code>co_call()</code>! co_call() will allocate a <code>coro</code>-struct on the coroutine-stack and execute
that just as any other coroutine. However it has some differences from co_init()+co_resume(). First of all, if it returns
on the first call the caller will not yield, it will just continue. If it do yield it will be resumed by co_begin() of the
caller until it completes and then the caller will continue at the yield-point introduced by co_call().
The resume of the sub-call could also have been done in the top-level co_resume() call but I decided to do it from the
caller just to preserve the callstack for debugging.
When the sub-call completes the stack will be reset to the point where <code>co_call()</code> allocated its <code>coro</code>-struct.</p>
<p>The above code will then be</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">some_game_object_behavior</span>( coro<span style="color:#f92672">*</span> co, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    co_begin(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... function ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        co_call(co, some_game_object_sub_behaviors1);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        co_call(co, some_game_object_sub_behaviors2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    co_end(co);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="call-arguments">call-arguments</h2>
<p>So how about argument to coroutines? You guessed it, lets just pass them on the stack! Both <code>co_init()</code> and <code>co_call()</code> has
versions that accepts a pointer to an argument + size/alignment. Example</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">some_game_object_move_on_path</span>( coro<span style="color:#f92672">*</span> co, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> path_index )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    move_me_on_path(<span style="color:#f92672">*</span>path_index); <span style="color:#75715e">// maybe this will yield until movement is complete!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">some_game_object_behavior</span>( coro<span style="color:#f92672">*</span> co, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> path_to_take; <span style="color:#75715e">// need to be declared before co_begin(), see below =/
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    co_begin(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... function ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    path_to_take <span style="color:#f92672">=</span> rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    co_call((co_func)some_game_object_move_on_path, <span style="color:#f92672">&amp;</span>path_to_take, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>), <span style="color:#66d9ef">alignof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    co_end(co);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above will allocate space for the int and copy it onto the stack, and run <code>some_game_object_move_on_path</code>. The last argument
to a <code>co_func</code> will be its arguments, or <code>nullptr</code> if not used.
An alert reader might have noticed that the argument is copied onto the stack and that is true&hellip; and its copied by <code>memcpy</code> so
keep the arguments simple. I guess you could add lots of c++ magic to move types and <em>yada yada</em> but I haven&rsquo;t needed that. IHMO
keeping types <code>memcpy</code>-able usually keeps code simpler and easier to work with!</p>
<blockquote>
<p>Note: there is also a version of co_call() and co_init() that deduce sizeof() and alignof() from arg.</p>
</blockquote>
<p>Again, no destructor will be run for the argument!
Lastly note the cast to (co_func)! I guess that this is not everyones cup of tea but personally I&rsquo;d rather take the cast there
than in the function itself but I guess that is a matter of taste.</p>
<h2 id="running-out-of-stack">Running out of stack!</h2>
<p>So what happens when/if we run out of stack, for example allocating locals, args or doing a <code>co_call()</code>? coro will handle that
gracefully and yield the coroutine at a point before the point of allocation.
When this happen <code>co_resume()</code> will return as usual and the state can be checked by <code>co_stack_overflowed()</code> and that can then be
handled by the user.
The simplest might just be to ASSERT() but there is also <code>co_stack_replace()</code> if you feel fancy and want to grow the stack.</p>
<p>An example of how this might work</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run_me</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> original_stack[<span style="color:#ae81ff">128</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    coro co;
</span></span><span style="display:flex;"><span>    co_init(<span style="color:#f92672">&amp;</span>co, original_stack, <span style="color:#66d9ef">sizeof</span>(original_stack), some_func);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>co_completed(<span style="color:#f92672">&amp;</span>co))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        co_resume(<span style="color:#f92672">&amp;</span>co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(co_stack_overflowed(<span style="color:#f92672">&amp;</span>co))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> old <span style="color:#f92672">=</span> co_stack_replace(<span style="color:#f92672">&amp;</span>co, malloc(co.stack_size <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>), co.stack_size <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(old <span style="color:#f92672">!=</span> original_stack)
</span></span><span style="display:flex;"><span>                free(old);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(co.stack <span style="color:#f92672">!=</span> original_stack)
</span></span><span style="display:flex;"><span>        free(co.stack);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="a-note-on-waiting">a note on &lsquo;waiting&rsquo;</h2>
<p>I mentioned above that I would like to be able to do things such as <code>wait_for( timeout, move_to )</code>. That is however something
that I have mostly left out of <code>coro</code>. Why you ask? Well, I can&rsquo;t really know how the user structures their code, how do they
want to update the coroutines etc.
If I would have supported something like that the lib would have become bigger and more &lsquo;opinionated&rsquo;, maybe it would have
needed an update and a manager of some kind etc. That would have brought the lib from being a simple building-block to something
more &ldquo;framework:y&rdquo; and that is not my intent. Maybe someday I&rsquo;ll do something like that but then it will be built upon <code>coro</code> not
built into it.
There is however one small helper for building this kind of code, and that is <code>co_wait()</code>. co_wait() is basically a <code>co_yield()</code>
that also sets a flag on the coroutine. This flag is also propagated through the currently running coroutine-callstack so that the
user can do <code>co_waiting(&amp;co)</code> at the top-level and see if it is waiting for something. This flag will be cleared on the next
call to <code>co_resume()</code>.
I think this little addition will be enough to build your own system on top of it if needed.</p>
<h1 id="conclusion">Conclusion</h1>
<p>First of all I need to say that I&rsquo;m curious to see if it really works when I actually start to use it ;)
I.e. my next task is to actually use this for something productive ( nope haven&rsquo;t done that yet! ). IMHO it feels promising but
we&rsquo;ll see.</p>
<p>Secondly let&rsquo;s take a look at some pros/cons of this approach.</p>
<h2 id="pro-no-platform-specific-code">Pro: No platform specific code</h2>
<p>This is IMHO a big win for a smaller team ( in this case me ). No need to support low-level asm-code to switch stacks and save
registers. No worries about &ldquo;what happens if we start porting to a new platform, can we do the same thing there?&rdquo;.</p>
<h2 id="pro-not-much-code">Pro: Not much code</h2>
<p>Also it is quite small ( at the time of writing 280 lines of code + 345 lines of comments ) and that is always a good thing
for maintenance and &ldquo;ease of use&rdquo;.</p>
<h2 id="con-easy-to-mess-up-locals">Con: Easy to mess up locals</h2>
<p>It is easy to mess up your local variables as it is second nature for every one of us to just declare a variable and expect it
to keep its value :)
My guess however is that you learn quickly and hopefully <code>co_locals_begin()/co_locals_end()</code> make it a bit easier.</p>
<h2 id="con-macro-heavy">Con: Macro-heavy</h2>
<p>Personally I&rsquo;m not that afraid of macros but I know some are. Also in this case they require you to follow quite a few rules and
if you break them you end up with quite hard to understand errors. Again I think this is something that you learn but the more of you
on your team the more people that have to learn and the fudge up a few times.</p>
<p>An macro-related error that can be quite hard to understand if you are new to the code is this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">some_game_object_behavior</span>( coro<span style="color:#f92672">*</span> co, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    co_begin(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... function ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> path_to_take <span style="color:#f92672">=</span> rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, path_to_take);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    co_yeald(co);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    co_end(co);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This code looks perfectly valid but generates this on my currently installed gcc.</p>
<blockquote>
<p>test/test_coro.cpp: In function ‘void some_game_object_behavior(coro*, void*, void*)’:
test/test_coro.cpp:43:16: error: jump to case label [-fpermissive]
co_yield(co);
^
test/test_coro.cpp:40:9: note:   crosses initialization of ‘int path_to_take’
int path_to_take = rand() % 5;</p>
</blockquote>
<p>Also stepping through the co_***-macros while debugging is far from pleasant, hopefully that is my problem and not
my users :)</p>
<h2 id="con-no-type-safety-for-arguments">Con: no type-safety for arguments</h2>
<p>Currently there is no real type-safety between args passed to co_call()/co_init() and the actual function used as a
coroutine callback. I would like to have that but I&rsquo;m not really sure that it is doable? Any ideas for solutions
would be appreciated ( easy on the meta-programming please ) !</p>
<h1 id="final-note">Final note</h1>
<p>I think this turned out nicely and hope that its something that might be useful for some of you. On a bigger team
with more resources, would I use this? Maybe? I think a full-scale stack-register switch might be a better solution
but that has its own caveats ( TLS-variables for example ).</p>
<p>Any thoughts or suggestions? I would love to hear about it!
Please hit me up on twitter or post in the coro issue-tracker! And remember, there will be bugs, there always is!</p>
<p>Check it out <a href="https://github.com/wc-duck/coro">https://github.com/wc-duck/coro</a>!</p>




      
        <div class="blog-tags">
          
            <a
              href="https://kihlander.net/tags/code/"
              >code</a
            >&nbsp;
          
            <a
              href="https://kihlander.net/tags/c&#43;&#43;/"
              >c&#43;&#43;</a
            >&nbsp;
          
            <a
              href="https://kihlander.net/tags/coroutines/"
              >coroutines</a
            >&nbsp;
          
        </div>
      

      
    </article>
    
    
      

    
  </div>

    <footer>
  

<div class="social-icons">
  
    
    
      
      <a href="https://twitter.com/wc_duck" name="twitter">
        <em class="fab fa-twitter"></em>
      </a>
    
       &nbsp;&ndash;&nbsp;
      <a href="https://mastodon.gamedev.place/@wcduck" name="mastodon">
        <em class="fab fa-mastodon"></em>
      </a>
    
       &nbsp;&ndash;&nbsp;
      <a href="https://github.com/wc-duck" name="github">
        <em class="fab fa-github"></em>
      </a>
    
       &nbsp;&ndash;&nbsp;
      <a href="mailto:fredrik.kihlander@gmail.com" name="mail">
        <em class="fa fa-envelope"></em>
      </a>
    
       &nbsp;&ndash;&nbsp;
      <a href="index.xml" name="rss">
        <em class="fas fa-rss"></em>
      </a>
    
  

  
</div>


  
  <div class="container">
    <p class="credits copyright">
      <a href="https://kihlander.net/about">Fredrik Kihlander</a>
      &nbsp;&copy;
      2024
      
        &nbsp;/&nbsp;
        <a href="https://kihlander.net/">What could possibly go wrong?</a>
      
      &nbsp;&ndash;&nbsp;
      <em class="fas fa-moon" id="dark-mode-toggle"></em>
    </p>

    <p class="credits theme-by">
      Powered By <a href="https://gohugo.io">Hugo</a>&nbsp;
      Theme
      <a href="https://github.com/matsuyoshi30/harbor">Harbor</a>
    </p>
  </div>
</footer>

  </body>
</html>
