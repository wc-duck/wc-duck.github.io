<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>The blog of Fredrik Kihlander</title><link>http://kihlander.net/</link><description>The blog of Fredrik Kihlander</description><atom:link href="http://kihlander.net/feeds/fredrik-kihlander.rss.xml" rel="self"></atom:link><lastBuildDate>Wed, 15 Nov 2017 00:00:00 +0100</lastBuildDate><item><title>A story about an unexpected ABI break</title><link>http://kihlander.net/a-story-about-an-unexpected-abi-break.html</link><description>&lt;p&gt;This is the story of an unexpected ABI break that I thought would be worth documenting.&lt;/p&gt;
&lt;p&gt;At Avalanche we use a small class wrapping 32bit hashes called CHashString, it is basically just a wrapper around
uint32_t and one should be able to treat it as a uint32_t in code except for operations that do not make sense on a hash-value.&lt;/p&gt;
&lt;p&gt;Why would you want a class like this you might ask, well we use it for adding a &lt;code&gt;const char* c_str()&lt;/code&gt;-function that can be
used in logging and also we use it to add custom natvis-support in visual studio so that you can just hover a CHashString
and have a lookup of the hash-value performed.&lt;/p&gt;
&lt;p&gt;However this is not about how we use it, but how things can break in unexpected ways.&lt;/p&gt;
&lt;p&gt;As a bit more background it should be mentioned that a big part of Avalanches internal libraries are distributed pre-compiled
to our game-projects with all the positives and negatives that brings with it. For example when deploying a middle-version fix
we "promise" to our projects that we do not break the ABI of the library, i.e. you should  be able to link with any 5.x.x if you
only depend on 5.x.x.&lt;/p&gt;
&lt;p&gt;Our CHashString was basically defined something like this&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CHashString&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;m_Hash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

    &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="n"&gt;CHashString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;m_Hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{}&lt;/span&gt;

    &lt;span class="n"&gt;CHashString&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;CHashString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CHashString&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;m_Hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;m_Hash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;constructors&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;functions&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;CHashString&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;m_Hash&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;m_Hash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As an earlier brain-fart/didn't-think-about-that someone added the copy-constructor, something that made this class non-trivially-copyable,
i.e. &lt;a href="http://en.cppreference.com/w/cpp/types/is_trivially_copyable"&gt;std::is_trivially_copyable&lt;/a&gt; would fail.
This would lead to putting it in some containers would not make it as performant as it should have been ( and it couldn't even live in some containers ).&lt;/p&gt;
&lt;p&gt;As the fixy kind of guy one am I said to my self "I can fix this, how hard can it be?". We decided that we should just remove that un-needed
copy-constructor since a default copy-constructor would do the same thing. Said and done, be gone with you!&lt;/p&gt;
&lt;p&gt;check-in!&lt;/p&gt;
&lt;p&gt;deploy!&lt;/p&gt;
&lt;p&gt;go for coffee!&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;Come back to crashing projects!&lt;/p&gt;
&lt;p&gt;Sad panda!&lt;/p&gt;
&lt;p&gt;Luckily for me it is easy to lock down versions of distributed libs so we could quickly fix the issues on the projects by locking down to the 
previous version.&lt;/p&gt;
&lt;p&gt;At this time we are scratching our heads quite a bit, our thinking being that even if one part of the code calls the old way of copy-constructing
an object the end result should be the same in memory... And to make things worse, most things seem to work.&lt;/p&gt;
&lt;p&gt;Time to bring out the debugger!&lt;/p&gt;
&lt;p&gt;I build a debug-build of one of our projects and after some time, thanks to some log-messages, I find a spot that behaves REALLY fishy!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;CHashString&lt;/span&gt; &lt;span class="nf"&gt;one_hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x12345678&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;CHashString&lt;/span&gt; &lt;span class="nf"&gt;another_hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x12345678&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// ... later in the code ...&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;one_hash&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;another_hash&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;do_stuff&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;do_stuff() is NEVER called!?! I.e. stuff is never done, and we all know that our job is mostly about getting stuff done ;) &lt;/p&gt;
&lt;p&gt;The debugger tell me that the 2 values are the same! What is going on here?
After checking the assembly and stepping the code quite a few times we can determine that when we removed the copy-constructor MSVC decided
that it should pass CHashString in register instead of by pointer to stack. So what our &lt;code&gt;operator==&lt;/code&gt; that take CHashString by-value ends up doing is 
comparing one of the hashes to half the stack-address of the other variable :)&lt;/p&gt;
&lt;p&gt;This since this code is defined in one of our pre-compiled libraries and the implementation of &lt;code&gt;operator==&lt;/code&gt; ends up in our main executable that
is built from latest the lib and the exe disagrees on how to pass values to the function!&lt;/p&gt;
&lt;p&gt;As expected this works in a release build where the code is inlined, but in that case we had other functions where how CHashString was passed was an issue.&lt;/p&gt;
&lt;p&gt;What can we learn from this? ABI-issues can show its ugly face when you least expect it and compilers do the darnedest things!&lt;/p&gt;
&lt;p&gt;Well, that was part of my day, how was yours? Feel free to hit me up on twitter or something if you want to give me a comment about this!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Fredrik Kihlander</dc:creator><pubDate>Wed, 15 Nov 2017 00:00:00 +0100</pubDate><guid>tag:kihlander.net,2017-11-15:a-story-about-an-unexpected-abi-break.html</guid><category>code</category><category>c++</category><category>war-stories</category></item><item><title>Builtin resources and the resource-system</title><link>http://kihlander.net/builtin-resources-and-the-resource-system.html</link><description>&lt;p&gt;I have written, in passing, about the resource-system and VFS ( Virtual File System ) I use in my own game-engine. This time it will however not be "in passing"
but will dig down a bit deeper into one "feature" in it that I find kind of neat. I'm sure it has been done before but I have not seen it myself somewhere else.
I'll be writing about how I handle builtin resources in the engine.&lt;/p&gt;
&lt;p&gt;When talking about a "builtin resource" I refer to resources generated by code and not read from files on disk such as a &lt;code&gt;red.png&lt;/code&gt; or a &lt;code&gt;cube.mesh&lt;/code&gt;. Resources read
from disk I'll refer to as "assets".
Builtin resources might be useful while prototyping in cases like "Oh, I'm creating an new enemy-type but I need some place-holder mesh and material while testing and
I just do not want to model a cube and paint a red texture"&lt;/p&gt;
&lt;h2&gt;How is the resource-system structured?&lt;/h2&gt;
&lt;p&gt;I think that we will have to start with describing how the resource-system works, just to get some fundamentals down.
In the bottom we have the VFS, or Virtual File System. That is just a system to hide access to "some kind of file-storage" ( file system, HTTP, archive-file etc ) where
all files are referenced as an absolute path such as &lt;code&gt;/assets/texture/apa.tex2d&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The VFS is in turn used by the resource-system that is a system with 2 purposes, creating/maintaining resource-containers and "turning VFS-paths to resources that can
be used in engine".
I.e. load file via VFS and pass the data on to a callback, maintain a "handle" returned by said callback.
A resource-container is just a collection of resources used to group resources such as &lt;code&gt;base_resources&lt;/code&gt; and &lt;code&gt;level_1_data&lt;/code&gt; etc.&lt;/p&gt;
&lt;p&gt;Well, as you can see it's fairly traditional :)&lt;/p&gt;
&lt;h2&gt;How about them builtin resources then!&lt;/h2&gt;
&lt;p&gt;So how do the engine handle the builtins then? Well, the paths to the VFS is always absolute and start at the root, i.e. start with a '/'. That opens up for "tagging"
paths as special. So if the path is not starting with a '/' it is not a valid VFS path and we could use that in the resource-system itself.
As I currently have it implemented the resource-system supports to path-formats:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/absolute/VFS/path&lt;/code&gt; - a file path in the VFS.
&lt;code&gt;:res_type:type_specific_desc&lt;/code&gt; - a builtin for a specific type.&lt;/p&gt;
&lt;p&gt;So if the path starts with, for example, &lt;code&gt;:tex2:&lt;/code&gt; or &lt;code&gt;:mesh:&lt;/code&gt; then the resource system just pass all that is right of the &lt;code&gt;:res_type:&lt;/code&gt; to a specific 
create_builtin_callback for the resource-type registered for that type.
Then it is up to the loading-code of the type ( tex/mesh/material etc ) to do what it pleases with the rest of the string.
The callback for the specific type then just goes ahead an creates the desired resource and returns a handle to it in the exact same way as when it creates the 
resource from and asset or report an error back to the resource-system on error.
I have ended up with just having all these paths '_'-separated and starting with a "base type" and followed by parameters, such as &lt;code&gt;:mesh:cube_dim_(1,2,1)_pos_(0,1,0)&lt;/code&gt;
to create a cube with dimensions 1,2,1 and center at 0,1,0 or &lt;code&gt;:tex2d:solid_col_FF0000FF&lt;/code&gt; to create a solid red 2d-texture.&lt;/p&gt;
&lt;h2&gt;Pros and cons with the system&lt;/h2&gt;
&lt;h1&gt;pros&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Works with all systems referencing a resource type.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I.e. you only have to implement "builtins" once for each type and whenever another system reference a resource it works with both assets and builtins automagically.
Both "particles" and "renderables" can access builtin meshes via the same code for example. So when referencing a resource by VFS-path it will automagically
work with builtins and by that works transparently from content.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Automatically hooks in to all parts of the resources system.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You will get all your builtin resources to use the same allocators and the ordinary assets, instance sharing will work ( 2 "things" reference 
&lt;code&gt;:tex2d:solid_col_FF0000FF&lt;/code&gt; and they will share texture-instance, debug-views showing loaded resources will show builtins, getting memory-statistics per 
container/resource-type works out of the box. In short, if it works with assets from disk it works with builtins.&lt;/p&gt;
&lt;h1&gt;cons&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Resources need to be identified by strings.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I would consider this the biggest issue and may make it unfeasible in a AAA-context where most of the times resources are identified by other types of ID:s.
For most hobbyists, small-sized and mid-sized projects I don't see that as a problem however as asset-counts and perf usually is "good enough (tm)" anyway.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String-parsing and an undocumented "language" that is different per resource-type.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This might also be a problem on a bigger team as the parsing need to handle errors well, warn clearly to the user what is wrong etc. Again on a smaller team where
team-members work close together and problems ( such as error handling and error-output ) can be fixed quickly I think it should work out well. However take a note
that it's just a guess since my own projects is on a team of size 1 where all members think exactly like me ;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Safety?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This might be an issue but nothing I have spent that much time on. As these codepaths might not be that well tested and hardened it might be a simple way "in" for a
malicious person if you are concerned by that. In that case you might want to just have this enabled during development.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I'll just conclude by saying that this is a system/feature that has worked out really well for me on my own stuff and has proven itself to be really useful. As
mentioned above it is really helpful to be able to reference "a red texture" or "a cube" directly via assets.&lt;/p&gt;
&lt;p&gt;What do you think? Has this been done before? Any other thoughts? Hit me up on twitter and tell me ( if you do it in a civil way of course! ;) )&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Fredrik Kihlander</dc:creator><pubDate>Mon, 07 Aug 2017 00:00:00 +0200</pubDate><guid>tag:kihlander.net,2017-08-07:builtin-resources-and-the-resource-system.html</guid><category>code</category><category>c++</category><category>assets</category></item><item><title>utf8_lookup, a write up.</title><link>http://kihlander.net/utf8_lookup-a-write-up.html</link><description>&lt;p&gt;I saw this blog post a while ago &lt;a href="http://reedbeta.com/blog/programmers-intro-to-unicode/"&gt;A Programmerâ€™s Introduction to Unicode&lt;/a&gt;, a really great write up that is a worth a
read for anyone interested in the subject! So go ahead and read that now even as it might not be super important for what I am about to write about here :)&lt;/p&gt;
&lt;p&gt;Reading this reminded me of an old project of mine that I think is a bit novel and deserves, at least, a write up. I am talking about &lt;a href="http://github.com/wc-duck/utf8_lookup/"&gt;utf8_lookup&lt;/a&gt;,
a small lib to translate utf8 chars into offsets into a table.&lt;/p&gt;
&lt;p&gt;It sprung out of the need to convert utf8-strings into bitmap-font glyhps for rendering. I.e. build some kind of data-structure out of a list of supplied codepoints and
then use that to translate strings into a lists of indices of valid glyphs or 0 if the glyph wasn't present in the original codepoint-list, i.e. rendering a bitmap font!
That is what I have been using it for but I guess there might be other uses for a sparse lookup structure like this as well.&lt;/p&gt;
&lt;p&gt;In short, this is what I have used it for (simplified):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;render_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;utf8_lookup_result&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;res_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ARRAY_LENGTH&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str_iter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str_iter&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;str_iter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;utf8_lookup_perform_scalar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str_iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;res_size&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;res_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;render_glyph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;some_glyph_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// some_glyph_data might contain things such as uv:s etc.&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The properties of the lib are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;low memory usage&lt;/li&gt;
&lt;li&gt;one memory chunk for the lookup structure with all (one) allocations done by the user.&lt;/li&gt;
&lt;li&gt;fairly quick ( we will get in to this later under "performance" )&lt;/li&gt;
&lt;li&gt;all non-found codepoints should map to offset 0 so that one can place a default-glyph there.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However I hadn't done any major profiling of the lib and I hadn't compared it to some other approaches to doing the same thing. Time to change that!&lt;/p&gt;
&lt;h2&gt;How does it work?&lt;/h2&gt;
&lt;p&gt;So now lets get to the meat of the post, how does it work?&lt;/p&gt;
&lt;p&gt;The lib basically builds compact search tree based on the ideas of a &lt;a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie"&gt;Hash Array Mapped Trie&lt;/a&gt;, HAMT for short, where each level of the
tree is based on each byte of an utf8-char.&lt;/p&gt;
&lt;p&gt;As stated earlier the entire lookup structure is stored as one buffer, a buffer with the following layout.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;item_cnt[uint64_t], availability-bits[uint64_t[item_cnt]], offsets[uint16_t[item_cnt]]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;item_cnt&lt;/td&gt;
&lt;td&gt;the amount of items in the following lists, kept as uint64_t for alignment reasons.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;availability-bits&lt;/td&gt;
&lt;td&gt;collection of bit-fields of what codepoints that are available in the lookup per "octet-byte".&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;offsets&lt;/td&gt;
&lt;td&gt;depending on the octet of the current char to translate and step in the translation-process the next offset in availability-bits or start of result-offset.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;By octet I refer to how many bytes the current utf8-char is consisting of.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The first section of our availability-bits is the "root" of our lookup-table where a small table is used to find where to start the lookup.
As octet one ( i.e. ASCII ) can have 128 possible values in utf8 ( first bit is 0 ) we need two slots in the availability bits where all other octets first byte fit in one 64-bit slots.&lt;/p&gt;
&lt;p&gt;So what is stored is something like this:
[ octet1 lower start ] [ octet1 higher start ] [ octet2 start ] [ octet3 start ] [ octet4 start ] ... [ octet2 bit1 ] [ octet2 bit2 ] ... [ octet3 bit1 ] ... [ octet3 bit1 bit2 ]&lt;/p&gt;
&lt;p&gt;What we are actually storing is info about groups of codepoints in subsequent bytes. I.e. we split the range of codepoints in chunks of 64 and if any char in that group is available in the
table that bit is set. This is true except in the "leaf" where it represent if the actual codepoint exists.
In short we have built a tree-structure with all levels having between 0 and 64 branches.&lt;/p&gt;
&lt;p&gt;Also, if an entire 64-bits chunk is 0, we do not store it at all so there will be no 64-bit chunk that is 0, if there is I have a bug :)&lt;/p&gt;
&lt;p&gt;Now to find the actual offset that are to be our result, we store offsets to where the next 64-bit chunk for the next byte in our codepoint is stored. By then storing all subservient levels
in the tree after each other as such:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;i will do this for 8 bits just to fit on the page :)&lt;/p&gt;
&lt;p&gt;avail_bits[some_index] = [00010110]
offset[some_index] = 16&lt;/p&gt;
&lt;p&gt;avail_bits[16-18] = is the next level in the tree
offsets[16-18] = offsets to the next level in the tree or final result-offsets.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As we only store one offset per level we need a way to find what item we need, but we do not want empty elements for the 0-bit. What we can do then is use base_offset + bits_set_before_checked_bit(),
an operation that can be performed really fast by modern hardware via the popcnt-instruction and fairly quick with some smart code if popcnt is not available.&lt;/p&gt;
&lt;p&gt;So the inner loop of the algorithm will look as follows.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="c1"&gt;// table telling where to start a lookup-traversal depending on how many bytes the current utf8-char is.&lt;/span&gt;
    &lt;span class="c1"&gt;// first item in the avail_bits is always 0, this is used as &amp;quot;not found&amp;quot;. If sometime in the lookup-loop&lt;/span&gt;
    &lt;span class="c1"&gt;// a char is determined that it do not exist, i.e. a bit in the avail_bits-array is not set, the current&lt;/span&gt;
    &lt;span class="c1"&gt;// lookup index will be set to 0 and reference this empty bitset for the rest of the lookup.&lt;/span&gt;
    &lt;span class="c1"&gt;//&lt;/span&gt;
    &lt;span class="c1"&gt;// This was done under the assumption that you mostly do lookups that &amp;quot;hit&amp;quot; the table, i.e. you will need&lt;/span&gt;
    &lt;span class="c1"&gt;// to do all loop-iterations so instead of branching, just make the code always loop all iterations.&lt;/span&gt;
    &lt;span class="c1"&gt;//&lt;/span&gt;
    &lt;span class="c1"&gt;// if this is a gain is something to actually be tested.&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;START_OFFSET&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="c1"&gt;// pos is the current position in the utf8-string to perform a lookup for.&lt;/span&gt;
    &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;first_byte&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;octet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UTF8_TRAILING_BYTES_TABLE&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;first_byte&lt;/span&gt; &lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;GROUP_MASK&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;127&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;63&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;GID_MASK&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;curr_offset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;START_OFFSET&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;octet&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;group_mask&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GROUP_MASK&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;octet&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;gid_mask&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GID_MASK&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;octet&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;octet&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// make sure that we get a value between 0-63 to decide what bit the current byte.&lt;/span&gt;
        &lt;span class="c1"&gt;// it is only octet 1 that will have more than 6 significant bits.&lt;/span&gt;
        &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;group_mask&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;// mask of the bits that is valid in this mask, only the first byte will have a&lt;/span&gt;
        &lt;span class="c1"&gt;// different amount of set bits. Thereof the table above.&lt;/span&gt;
        &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;gid&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;gid_mask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;check_bit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;gid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;// gid mask will always be 0b111111 i.e. the lowest 6 bit set on all loops except&lt;/span&gt;
        &lt;span class="c1"&gt;// the first one. This is due to how utf8 is structured, see table at the top of&lt;/span&gt;
        &lt;span class="c1"&gt;// the file.&lt;/span&gt;
        &lt;span class="n"&gt;gid_mask&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;// index in avail_bits and corresponding offsets that we are currently working in.&lt;/span&gt;
        &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;curr_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;// how many bits are set &amp;quot;before&amp;quot; the current element in this group? this is used&lt;/span&gt;
        &lt;span class="c1"&gt;// to calculate the next item in the lookup.&lt;/span&gt;
        &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;items_before&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;utf8_popcnt_impl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;avail_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;check_bit&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;has_popcnt&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// select the next offset in the avail_bits-array to check or if this is the last iteration this&lt;/span&gt;
        &lt;span class="c1"&gt;// will be the actual result.&lt;/span&gt;
        &lt;span class="c1"&gt;// note: if the lookup is a miss, i.e. bit is not set, point curr_offset to 0 that is a bitfield&lt;/span&gt;
        &lt;span class="c1"&gt;//       that is always 0 and offsets[0] == 0 to just keep on &amp;quot;missing&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;curr_offset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;avail_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;check_bit&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint64_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;offsets&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nl"&gt;items_before&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// curr_offset is now either 0 for not found or offset in glyphs-table&lt;/span&gt;

    &lt;span class="n"&gt;res_out&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;curr_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Performance&lt;/h2&gt;
&lt;p&gt;To test out the performance of the solution I have written a small benchmark app that is testing 4 different approaches to doing this and measuring some different stats&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;memory usage&lt;ul&gt;
&lt;li&gt;total&lt;/li&gt;
&lt;li&gt;amount of allocations&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;speed&lt;ul&gt;
&lt;li&gt;GB/sec&lt;/li&gt;
&lt;li&gt;ms/10000 codepoints&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These benchmarks runs over quite a few texts in various languages. Downloaded from &lt;a href="www.gutenberg.org"&gt;The Project Gutenberg&lt;/a&gt;. I have tried to get a good spread over
different kind of texts using different combinations of code-pages etc.&lt;/p&gt;
&lt;p&gt;The benchmarks will perform a complete "translation" of each text 100 times in a row.&lt;/p&gt;
&lt;p&gt;The tested approaches for doing this are as follows&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use utf8_lookup with a native popcnt instruction&lt;/li&gt;
&lt;li&gt;use utf8_lookup without a native popcnt instruction&lt;/li&gt;
&lt;li&gt;stuff all codepoint/offset pairs into an std::map&lt;/li&gt;
&lt;li&gt;stuff all codepoint/offset pairs into an std::unordered_map&lt;/li&gt;
&lt;li&gt;bitarray with native popcnt&lt;/li&gt;
&lt;li&gt;bitarray without native popcnt&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The bitarray-approach is just having a big array of uint64_t, set the bit if the codepoint exists, store an offset per uint64_t, and get the result-offset as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;res = offsets[codepoint / 64] + bits_set_before(lookup[codepoint / 64])&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;basically utf8_lookup without compression.&lt;/p&gt;
&lt;p&gt;Finally its time for some numbers and charts!&lt;/p&gt;
&lt;p&gt;Texts used and results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;file&lt;/th&gt;
&lt;th&gt;codepoint count&lt;/th&gt;
&lt;th&gt;bpcp utf8_lookup&lt;/th&gt;
&lt;th&gt;bpcp bitarray&lt;/th&gt;
&lt;th&gt;bpcp std::map&lt;/th&gt;
&lt;th&gt;bpcp std::unordered_map&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ancient_greek.txt&lt;/td&gt;
&lt;td&gt;222&lt;/td&gt;
&lt;td&gt;0.891892&lt;/td&gt;
&lt;td&gt;5.810811&lt;/td&gt;
&lt;td&gt;40.0&lt;/td&gt;
&lt;td&gt;30.342342&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stb_image.h&lt;/td&gt;
&lt;td&gt;95&lt;/td&gt;
&lt;td&gt;0.505263&lt;/td&gt;
&lt;td&gt;0.019531&lt;/td&gt;
&lt;td&gt;40.0&lt;/td&gt;
&lt;td&gt;23.242105&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chinese1.txt&lt;/td&gt;
&lt;td&gt;3529&lt;/td&gt;
&lt;td&gt;0.971380&lt;/td&gt;
&lt;td&gt;2.893171&lt;/td&gt;
&lt;td&gt;40.0&lt;/td&gt;
&lt;td&gt;24.451118&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chinese2.txt&lt;/td&gt;
&lt;td&gt;3540&lt;/td&gt;
&lt;td&gt;0.959887&lt;/td&gt;
&lt;td&gt;2.884181&lt;/td&gt;
&lt;td&gt;40.0&lt;/td&gt;
&lt;td&gt;24.424858&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chinese3.txt&lt;/td&gt;
&lt;td&gt;4226&lt;/td&gt;
&lt;td&gt;0.818268&lt;/td&gt;
&lt;td&gt;2.415996&lt;/td&gt;
&lt;td&gt;40.0&lt;/td&gt;
&lt;td&gt;30.209181&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;danish.txt&lt;/td&gt;
&lt;td&gt;111&lt;/td&gt;
&lt;td&gt;1.333333&lt;/td&gt;
&lt;td&gt;11.351352&lt;/td&gt;
&lt;td&gt;40.0&lt;/td&gt;
&lt;td&gt;29.549549&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;germain.txt&lt;/td&gt;
&lt;td&gt;133&lt;/td&gt;
&lt;td&gt;1.413534&lt;/td&gt;
&lt;td&gt;10.526316&lt;/td&gt;
&lt;td&gt;40.0&lt;/td&gt;
&lt;td&gt;27.308271&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;esperanto.txt&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;1.229167&lt;/td&gt;
&lt;td&gt;13.437500&lt;/td&gt;
&lt;td&gt;40.0&lt;/td&gt;
&lt;td&gt;23.166666&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;japanese.txt&lt;/td&gt;
&lt;td&gt;2176&lt;/td&gt;
&lt;td&gt;1.506434&lt;/td&gt;
&lt;td&gt;4.191961&lt;/td&gt;
&lt;td&gt;40.0&lt;/td&gt;
&lt;td&gt;28.232977&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;japanese2.txt&lt;/td&gt;
&lt;td&gt;2438&lt;/td&gt;
&lt;td&gt;1.506434&lt;/td&gt;
&lt;td&gt;4.696691&lt;/td&gt;
&lt;td&gt;40.0&lt;/td&gt;
&lt;td&gt;29.705883&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;russian.txt&lt;/td&gt;
&lt;td&gt;145&lt;/td&gt;
&lt;td&gt;0.882759&lt;/td&gt;
&lt;td&gt;8.896552&lt;/td&gt;
&lt;td&gt;40.0&lt;/td&gt;
&lt;td&gt;26.372414&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;big.txt&lt;/td&gt;
&lt;td&gt;6069&lt;/td&gt;
&lt;td&gt;0.607678&lt;/td&gt;
&lt;td&gt;1.683968&lt;/td&gt;
&lt;td&gt;40.0&lt;/td&gt;
&lt;td&gt;25.894217&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;bpcp = bytes per codepoint&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;All tests has been run on my private machine, an Intel(R) Core(TM) i7-4770K CPU @ 3.50GHz with 16GB DDR3 RAM running Ubuntu 14.04.5 LTS.&lt;/p&gt;
&lt;p&gt;All builds has been done with g++ (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4.&lt;/p&gt;
&lt;p&gt;Optimized builds has been compiled with&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;g++ -Wconversion -Wextra -Wall -Werror -Wstrict-aliasing=2 -O2 -std=gnu++0x -Wconversion -Wextra -Wall -Werror -Wstrict-aliasing=2 -O2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And debug builds with&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;g++ -Wconversion -Wextra -Wall -Werror -Wstrict-aliasing=2 -std=gnu++0x -Wconversion -Wextra -Wall -Werror -Wstrict-aliasing=2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;First lets get this out of the room, the std::map/unordered_map versions are really bad compared to the others in all measurements. That was expected but I added them to
the tests as it is something that is the "first thing that comes to mind" and something I wouldn't be surprised to see in a codebase.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Memory use" src="http://kihlander.net/images/memuse_all.png" title="Memory use" /&gt;
&lt;img alt="GB/sec" src="http://kihlander.net/images/gb_per_sec.png" title="GB/sec" /&gt;&lt;/p&gt;
&lt;p&gt;As we can see the memory used and performance ( in GB text translated per second ) by the std::-implementations are just huge compared to the other to solutions, so lets 
remove them to get some more interesting charts :)&lt;/p&gt;
&lt;p&gt;&lt;img alt="Bytes per codepoint" src="http://kihlander.net/images/bytes_per_cp_no_std.png" title="Bytes per codepoint" /&gt;
&lt;img alt="GB/sec" src="http://kihlander.net/images/gb_per_sec_no_std.png" title="GB/sec" /&gt;&lt;/p&gt;
&lt;p&gt;The charts clearly show that utf8_lookup outperforms the bitarray in all cases except pure ASCII ( stb_image.h ) when it comes to memory-usage and loses when it comes to
raw lookup performance in all tests.
We can also mention that the "tighter" the codepoints to lookup are, the more comparable the both techniques are. We could also plot bytes-per-codepoint vs lookup perf.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Perf vs bits-per-codepoint" src="http://kihlander.net/images/bpcp_vs_cppus_no_std.png" title="Perf vs bits-per-codepoint" /&gt;&lt;/p&gt;
&lt;p&gt;In this chart we can clearly see each approach "banding" on bytes-per-codepoint and lookup-perf.&lt;/p&gt;
&lt;p&gt;We'll end with mentioning performance in an non-optimized build as well, something that I find usually is lacking. OK performance in a debug-build is really something that
will make your life easier and something I find to be a well worthy goal to strive for.&lt;/p&gt;
&lt;p&gt;&lt;img alt="GB/sec" src="http://kihlander.net/images/gb_per_sec_debug.png" title="GB/sec" /&gt;&lt;/p&gt;
&lt;p&gt;It's the same pattern here, the std::-based solutions are just getting crushed and the simple array is by far the fastest but IMHO utf8_lookup holds its ground pretty well.
A colleague of mine also pointed out that this is with gcc:s implementation of the STL, if this would have been run with some other STL implementations ( among others the one
used in msvc ) the debug-results would have been even worse.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;It has been quite interesting to test and benchmark this solution. I guess the findings can be summarized as follows, if you want pure performance nothing beats a simple array
( nothing new under the sun here! ), however utf8_lookup performs really well when it comes to memory-usage.&lt;/p&gt;
&lt;p&gt;I also think that there might be other approaches worth testing and adding benchmarks for here and maybe some more investigations into what governs performance. My guess is cache, i.e.
depending on how the indexed codepoints are distributed it could give better or worse cache-utilization.&lt;/p&gt;
&lt;p&gt;There might also be gains to be had in the actual utf8_lookup implementation, for example one might change the order of how the internal items are stored to better group used
memory chunks depending on access-patters. It might be interesting to generate some "heatmaps" of used codepoints for the different texts and see if a patter emerges.&lt;/p&gt;
&lt;p&gt;However as I am, depending on when your read this, the father of 2 this is all that I have the time and energy for now and it is good enough for the small things I use it for.&lt;/p&gt;
&lt;p&gt;I hope that this might be useful for someone, maybe it can be used for something other than what I have used it for? And if there is something to really take away from this is that
base_offset + (popcnt(bits_before)) is a really sweet technique that can be used for many things :)&lt;/p&gt;
&lt;p&gt;Have I missed any benchmark approach? Any improvements that I could do? Anything else? Feel free to contact me on twitter!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Fredrik Kihlander</dc:creator><pubDate>Mon, 26 Jun 2017 00:00:00 +0200</pubDate><guid>tag:kihlander.net,2017-06-26:utf8_lookup-a-write-up.html</guid><category>code</category><category>c++</category><category>utf8</category></item><item><title>Why I prefer inline forward-declares in C++</title><link>http://kihlander.net/why-i-prefer-inline-forward-declares-in-c.html</link><description>&lt;p&gt;Time for a short post on how I usually do the humble forward declare in C++. I guess this is not something new but it is something I usually do not see in
others code so it feels worth sharing.&lt;/p&gt;
&lt;p&gt;So lets start of with just defining what we are talking about just to get everyone on the same page, we are talking about declaring only a class/struct name
to the compiler and not having to provide the entire class/struct declaration. Mostly used as a compile-time optimization or to handle circular deps etc.&lt;/p&gt;
&lt;p&gt;A simple example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// forward declare this struct.&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;a_forward_declared_struct&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;my_struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;a_forward_declared_struct&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;a_forward_declared_pointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;my_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;a_forward_declared_struct&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;another_pointer&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We're all used to see this kind of code, nothing new under the sun. I however like to write it like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;my_struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;a_forward_declared_struct&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;a_forward_declared_pointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;my_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;a_forward_declared_struct&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;another_pointer&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I don't know if inline-forward-declare is the correct term, but we'll use that until I'm told otherwise ;)&lt;/p&gt;
&lt;p&gt;So what is better with this more verbose variant? Well, I have 2 reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It do not "leak" definitions into the global namespace.&lt;/li&gt;
&lt;li&gt;When usage is removed, so is the forward declare.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lets go through them one-by-one.&lt;/p&gt;
&lt;h2&gt;It do not "leak" definitions into the global namespace.&lt;/h2&gt;
&lt;p&gt;The big thing here is that we can't break other code by removing our forward declares. Say that you have this code:&lt;/p&gt;
&lt;p&gt;&amp;lt;&lt;em&gt;header1.h&lt;/em&gt;&amp;gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;a_forward_declared_struct&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;my_func1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;a_forward_declared_struct&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;another_pointer&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&amp;lt;&lt;em&gt;header2.h&lt;/em&gt;&amp;gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;my_func2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;a_forward_declared_struct&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;another_pointer&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// OH NOES, we forgot our forward declare!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;file.cpp&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;header1.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;header2.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;a_forward_declared_struct.h&amp;quot; // defining the actual struct.&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;a_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;a_forward_declared_struct&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;my_func2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we work with our code and refactor my_func1() to no longer take a pointer to a &lt;code&gt;a_forward_declared_struct&lt;/code&gt; and removing the forward declare.
By doing this we break file.cpp since "header2.h" is now "incomplete". This might not be a big issue in a smaller code-base but in a bigger one
(especially one using unity-builds, batch-builds or whatever you want to call them ) this can pop up on another colleagues machine after you have
submitted your code.&lt;/p&gt;
&lt;p&gt;If instead you would have used inline forward-declares header2.h would never have compiled to begin with so the initial implementer would not have
missed the needed declarations.&lt;/p&gt;
&lt;h2&gt;When usage is removed, so is the forward declare.&lt;/h2&gt;
&lt;p&gt;The second improvement over the "ordinary" declarations is the fact that they are automatically removed when they are no longer needed since they
are part of the actual code.&lt;/p&gt;
&lt;p&gt;How many times haven't we all found forward declares that no one uses ( and no one want to remove due to point 1 ;) ).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Some thing like:&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;i_have_no_vec3&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;apa&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;kossa&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// I had a vec3 here a few years ago!&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Final words&lt;/h2&gt;
&lt;p&gt;Are there any drawbacks? Well, except for being slightly more verbose, the only one I can think of is that it do not work together with namespaces.
For me that is no real problem since I really do not like namespaces to begin with ( topic for another rant/blog-post? ) but if you do this tip
is not as useful. If you mix and match I would still recommend using inline forward-declares where possible and fallback to namespace:d declares
when you have to.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Do you agree, am I totally wrong? Feel free to tell me on twitter!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Fredrik Kihlander</dc:creator><pubDate>Mon, 14 Nov 2016 00:00:00 +0100</pubDate><guid>tag:kihlander.net,2016-11-14:why-i-prefer-inline-forward-declares-in-c.html</guid><category>code</category><category>c++</category></item><item><title>Compile-time hashes in c++, im not convinced!</title><link>http://kihlander.net/compile-time-hashes-in-c-im-not-convinced.html</link><description>&lt;p&gt;I recently read a blogpost about &lt;a href="http://blog.demofox.org/2016/09/23/exploring-compile-time-hashing/"&gt;compile-time string-hashes and constexpr&lt;/a&gt; and I'm still not convinced and 
see no real reason to leave my old and true friend the script :)&lt;/p&gt;
&lt;p&gt;So first of lets look at the problem we want to solve. We want a way to do things like this and not pay the runtime cost ( and in this case just compile! ).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;my_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;HashOfString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;some_string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;do_some_stuff&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;HashOfString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;some_other_string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;do_some_other_stuff&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Simple enough. What seems to come up over and over again is ways of doing this with the compiler compile-time and now recently just marking &lt;code&gt;HashOfString&lt;/code&gt; as &lt;code&gt;constexpr&lt;/code&gt; and "trust the compiler".
The solution I usually fall back to is to just have a text-file where each line is hashed with a custom script and written to a .h file with values such as:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;my_hashes.hash&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;some string
some other string
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;my_hashes.hash.h&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#pragma once&lt;/span&gt;

&lt;span class="cp"&gt;#define HASH_some_string       0xABCD0123 &lt;/span&gt;&lt;span class="c1"&gt;// hash of &amp;quot;some_string&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#define HASH_some_other_string 0x0123ABCD &lt;/span&gt;&lt;span class="c1"&gt;// hash of &amp;quot;some_other_string&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;usage in code&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;my_hashes.hash.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;my_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;HASH_some_string&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;do_some_stuff&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;HASH_some_other_string&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;do_some_other_stuff&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With a resonable buildsystem in place this can be automated and never be in your way. I have it setup to collect all &lt;code&gt;&amp;lt;filename&amp;gt;.hash&lt;/code&gt;-files and output &lt;code&gt;&amp;lt;filename&amp;gt;.hash.h&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So lets compare the different solutions and see why I prefer the one I do by just listing my perceived pros/cons.&lt;/p&gt;
&lt;p&gt;The biggest pro for using the c++-compiler itself for this is to not need a custom buildstep for the hashes and that is a really fair point. No need to setup a buildsystem or manually generate 
the headers can really be an important point in some cases, especially when distributing code to others. Also having the hashed string where it is used is by some considered a pro, for me it is
a + but a small one.
But that is about where the pros stop i.m.h.o.&lt;/p&gt;
&lt;p&gt;On the cons list I think the biggest 2 are that I have to trust the compiler to do the right thing and paying the cost for generating this each time I compile my code.&lt;/p&gt;
&lt;p&gt;Let's start of with the first one, trusting the compiler. Sure, compilers are smart etc but are we sure that the compiler will optimize a &lt;code&gt;HashOfString("some_string)&lt;/code&gt; to a constant? If it does
with your current compiler, will it with another compiler? What happens when a new version of your compiler is released?
With the simple "generate a .h"-file I am quite sure that it will evaluate to a constant and I will not have to think about it.&lt;/p&gt;
&lt;p&gt;The other issue with compile-time hashes in pure c++ is why pay for something all the time when you can pay for it once? I.e. if I put code in a .cpp to generate a hash by the compiler it will
cost time each time I compile that file. When generating a header I pay for it once, when I change the text-file with the strings to hash.&lt;/p&gt;
&lt;p&gt;We also have some other pros that are not as big, but I might just as well list them here for completeness:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;easier to find the actual value of the hash. When generating a header you just look in the header, when doing it with the compiler... it gets harder!&lt;/li&gt;
&lt;li&gt;you have control over how the header is generated, you want to add registering of hash-value -&amp;gt; string? just add it!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So what do you think, what pros have I missed on hashing with the c++-compiler? Why am I wrong? &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Fredrik Kihlander</dc:creator><pubDate>Sat, 24 Sep 2016 00:00:00 +0200</pubDate><guid>tag:kihlander.net,2016-09-24:compile-time-hashes-in-c-im-not-convinced.html</guid><category>code</category><category>c++</category></item><item><title>The command-line as a poor mans config files</title><link>http://kihlander.net/the-command-line-as-a-poor-mans-config-files.html</link><description>&lt;p&gt;I like command-line arguments as mentioned in an earlier &lt;a href="http://kihlander.net/registering-command-line-arguments.html"&gt;post&lt;/a&gt; about them. In this 
post I'll discuss a method to use them as simple config-files.&lt;/p&gt;
&lt;p&gt;Let's start of with a usage example from my own code. I have a meshviewer/particleviewer that is used for, you guessed it, viewing meshes
and particle-effects. These kind of resources, at least the particle-effects, have internal paths to resources that need to be read while
loading ( particles have a material to be rendered with etc ), i.e. resources from "some game" need to be found by the particle-viewer.
Since reading resources is done via a VFS ( Virtual File System ) and paths is always specified via this VFS in resources we must just make
sure that "some game":s resources is mounted in the particle-viewer!&lt;/p&gt;
&lt;p&gt;Luckily for me this can be done via, you guessed it, the command line!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    ./meshviewer --vfs-mount-uri&lt;span class="o"&gt;=&lt;/span&gt;file:///path/to/assets --vfs-mount-point&lt;span class="o"&gt;=&lt;/span&gt;/assets/ /assets/mesh/mesh_in_game_to_view.mesh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nice! But writing out this when you want to just test a resource from one project might be hard to remember and a bit of a hassle =/
So lets add one more command-line switch, &lt;code&gt;--cmd-file=&amp;lt;path_to_file&amp;gt;&lt;/code&gt;!
What this simply does is read the pointed to file, split it at white-space, add it to argc/argv. TADA! simple config-files done + all
that can be configurate via files can also be configurated via the command-line.&lt;/p&gt;
&lt;p&gt;If we let &lt;code&gt;--cmd-file=&amp;lt;path_to_file&amp;gt;&lt;/code&gt; be recursive, we can do sub-files as well.&lt;/p&gt;
&lt;p&gt;The above then becomes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    ./meshviewer --cmd-file&lt;span class="o"&gt;=&lt;/span&gt;setup_some_game.cmd /assets/mesh/mesh_in_game_to_view.mesh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In this specific case it might not save you that much, but consider you having multiple games, multiple configs etc.&lt;/p&gt;
&lt;p&gt;Do I think this would replace all configuration ever? Absolutely not, but it works great for small things as above. I would absolutely not
do this for settings that should be used in a shipped game, only for debug-settings and other settings used during development.&lt;/p&gt;
&lt;p&gt;Short post, but hopefully someone like this and steal it :)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Fredrik Kihlander</dc:creator><pubDate>Tue, 01 Mar 2016 00:00:00 +0100</pubDate><guid>tag:kihlander.net,2016-03-01:the-command-line-as-a-poor-mans-config-files.html</guid><category>code</category><category>c++</category></item><item><title>Registering command line arguments</title><link>http://kihlander.net/registering-command-line-arguments.html</link><description>&lt;p&gt;I really like using command line arguments. I think that it is a flexible way to interact with and configure my games/engine.
It is for example easier to just add a &lt;code&gt;--log-verbose=resource&lt;/code&gt; to set all logging in the "resource"-domain to verbose or
&lt;code&gt;--memory-enable-stacktrace=render&lt;/code&gt; to enable save of stacktraces for all allocations done in the "render"-allocator than to
edit some config-file somewhere. At least for things such as the ones mentioned above, that is only set once in a while.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note: It's also a simple replacement for config-files, but that is something for a later blog-post ;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;However it seems like there's always one problem, how to register supported command-line arguments to show --help and 
check that arguments are correctly specified?
In this blog-post I'll outline a solution that I have found works really well for me. It has its drawbacks but that is usually
the case with any solution to any problem ;)&lt;/p&gt;
&lt;h2&gt;What do I want to achieve?&lt;/h2&gt;
&lt;p&gt;Let's make a quick list over what I want from my system.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Different systems to be able to register their supported command line arguments in a simple fashion.&lt;/li&gt;
&lt;li&gt;Automatic --help generation ( I always forget what flags are there etc, --help to the rescue )&lt;/li&gt;
&lt;li&gt;Systems that register args should be able to assume that all flags are valid when they get the args.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;How I do it&lt;/h2&gt;
&lt;p&gt;First of all I let all systems parse their own argc/argv, in other words I just pass each system a reference to argc/argv.
This is done in different ways, but usually something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;log_ctx_t&lt;/span&gt; &lt;span class="n"&gt;logger&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;log_ctx_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="cm"&gt;/*... some param ... */&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;or this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;renderer_create_info&lt;/span&gt; &lt;span class="n"&gt;create_info&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ... other params ...&lt;/span&gt;
    &lt;span class="n"&gt;create_info&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;create_info&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;renderer_t&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;renderer_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;create_info&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The systems get access to a const argc/argv and its their job to parse them by them self. For this I use ( shameless self-promotion comming up ) 
this getopt-parser https://github.com/wc-duck/getopt. But how does that tie in with our earlier demands on the "system".
Well, lets use some thing that some one consider the c++-equivalent of swearing in church, global constructors! Lets introduce
a simple helper-class and macro &lt;code&gt;GETOPT_ARGS_REGISTER()&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;__getopt_args_register&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;__getopt_args_register&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;getopt_option_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;opt&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;options_title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;opt&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;__getopt_args_register&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;__getopt_args_register&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;             &lt;span class="n"&gt;options_title&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;getopt_option_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;  &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="cp"&gt;#define GETOPT_ARGS_REGISTER( options_title, options ) \&lt;/span&gt;
&lt;span class="cp"&gt;    static __getopt_args_register JOIN_MACRO_TOKENS( __getopt_reg, __LINE__ )( options_title, options )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And we use this as follows&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;getopt_option_t&lt;/span&gt; &lt;span class="n"&gt;options_list&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;log-info&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;      &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GETOPT_OPTION_TYPE_OPTIONAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;i&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;set log-level info, globally if no domain is specified.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;   &lt;span class="s"&gt;&amp;quot;DOMAIN&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;log-error&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GETOPT_OPTION_TYPE_OPTIONAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;set log-level error, globally if no domain is specified.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;DOMAIN&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;log-warning&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;   &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GETOPT_OPTION_TYPE_OPTIONAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;set log-level warning, globally if no domain is specified&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;DOMAIN&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;log-verbose&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;   &lt;span class="sc"&gt;&amp;#39;v&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GETOPT_OPTION_TYPE_OPTIONAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;v&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;set log-level verbose, globally if no domain is specified&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;DOMAIN&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;log-callstack&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GETOPT_OPTION_TYPE_OPTIONAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;log callstacks together with messages, globally if no domain is specified&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;DOMAIN&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;log-domains&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;   &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GETOPT_OPTION_TYPE_NO_ARG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;   &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;log all available domains as they are discovered.&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="n"&gt;GETOPT_OPTIONS_END&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="n"&gt;GETOPT_ARGS_REGISTER&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;log&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;options_list&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;What the above macro basically does is on old trick, building an global linked list of __getopt_args_register when running global constructors that 
can be accessed via &lt;code&gt;__getopt_args_register::first&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When we have this info it is an easy thing to just loop over all registered args and do the error checking and --help generation etc without the systems
having to know about it. I usually do this as a really early part of &lt;code&gt;int main( int argc, const char** argv )&lt;/code&gt;.
Also notice that the registered options is the same type that is used by the getopt-library so that the same setup can be used during arg-parse. Keeping the
registered args defined in one place and one place only.&lt;/p&gt;
&lt;p&gt;One of the things I like most with this is that the registering is done link-time, so linking to a static library, in my case render, debug or vfs ( to 
mention a few ) auto-registers its options. So if a lib is not used/linked, no options is registered.&lt;/p&gt;
&lt;h2&gt;Drawbacks&lt;/h2&gt;
&lt;p&gt;Well there are some of course. This will not work well together will DLL:s since the main .exe and the .dll:s will get their own instance of 
&lt;code&gt;__getopt_args_register::first&lt;/code&gt; and the ones in the dll will not be accessible from the exe. It could  be solved by "pulling out" &lt;code&gt;__getopt_args_register::first&lt;/code&gt; 
from each DLL and manually "link" them together but that is not something I have done or have had any need for.&lt;/p&gt;
&lt;p&gt;Also there is the problem of colliding flag-names and that is best solved by just not sharing flag-names, I prefix my flags by system. In some cases you might even
want colliding flag-names where you have flags that should be used by multiple systems. Not sure if it is a good idea, but it is definitely something that can be
done.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This is a technique that has served me well for this purpose and the "global linked list created with global constructors" could be a useful tool in your toolbox 
when writing c++. It need to be used restrictively, but at least for this purpose it has not been any problems for me.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Fredrik Kihlander</dc:creator><pubDate>Sat, 27 Feb 2016 00:00:00 +0100</pubDate><guid>tag:kihlander.net,2016-02-27:registering-command-line-arguments.html</guid><category>code</category><category>c++</category></item></channel></rss>